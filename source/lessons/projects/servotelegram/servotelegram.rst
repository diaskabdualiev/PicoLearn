Управление сервоприводом через Telegram-бот
=====================================================================

Введение
-----------------------------------------

В этом уроке мы научимся управлять сервоприводом с помощью Telegram-бота на Raspberry Pi Pico W. Мы создадим бота, который будет принимать команды для установки угла поворота сервопривода в формате `/servo 90`. Это позволит нам дистанционно управлять физическими объектами через мессенджер Telegram, что является отличным примером практического применения IoT (Интернета вещей).

Необходимые компоненты
-----------------------------------------

- Raspberry Pi Pico W
- Сервопривод (например, SG90 или MG996R)
- Кабель Micro-USB для подключения к компьютеру
- Провода для подключения сервопривода
- Доступ к Wi-Fi сети
- Аккаунт в Telegram
- Источник питания 5В (опционально, для питания сервопривода при больших нагрузках)

Теория работы сервопривода
-----------------------------------------

Сервопривод (сервомотор) - это мотор с обратной связью, который может точно поворачивать вал на заданный угол. Стандартный сервопривод имеет три провода:
- VCC (красный) - питание (+5В)
- GND (коричневый или черный) - земля (0В)
- Signal (желтый или оранжевый) - сигнальный провод для управления

Сервоприводы управляются с помощью ШИМ (PWM, Pulse Width Modulation) сигнала. Положение вала сервопривода определяется шириной импульса:
- Импульс 1 мс (1000 мкс) соответствует повороту в 0 градусов
- Импульс 1.5 мс (1500 мкс) соответствует повороту в 90 градусов (среднее положение)
- Импульс 2 мс (2000 мкс) соответствует повороту в 180 градусов

Частота следования импульсов обычно составляет 50 Гц (период 20 мс).

Схема подключения
-----------------------------------------

Подключение сервопривода к Raspberry Pi Pico W:

- VCC сервопривода к VBUS (5В) Pico W (PIN 40)
- GND сервопривода к GND Pico W (PIN 38)
- Signal сервопривода к GP15 (PIN 20) Pico W

.. note::
    
    Если сервопривод потребляет большой ток (например, MG996R), рекомендуется использовать внешний источник питания 5В и соединить только GND внешнего источника с GND Pico W для общего заземления. В этом случае не подключайте VCC сервопривода к Pico W.

Структура проекта
-----------------------------------------

Наш проект будет состоять из следующих файлов:
- telegram.py - библиотека для работы с Telegram API (предоставлена)
- config.py - конфигурационный файл с настройками Wi-Fi, токеном бота и параметрами сервопривода
- main.py - основной файл программы с логикой бота и управлением сервоприводом

Код проекта
-----------------------------------------

1. Сначала создадим файл конфигурации (config.py):

.. code-block:: python

    # Конфигурационный файл для проекта управления сервоприводом
    
    # Настройки Wi-Fi
    WIFI_SSID = "Название_вашей_сети"
    WIFI_PASSWORD = "Пароль_вашей_сети"
    
    # Токен Telegram бота (получен от BotFather)
    BOT_TOKEN = "ваш_токен_от_botfather"
    
    # Настройки сервопривода
    SERVO_PIN = 15           # Номер GPIO пина для сервопривода (GP15)
    SERVO_MIN_PULSE = 500    # Минимальная длительность импульса в микросекундах (0 градусов)
    SERVO_MAX_PULSE = 2500   # Максимальная длительность импульса в микросекундах (180 градусов)
    SERVO_FREQ = 50          # Частота ШИМ сигнала в Гц
    
    # Ограничения угла поворота
    MIN_ANGLE = 0            # Минимальный угол поворота
    MAX_ANGLE = 180          # Максимальный угол поворота
    
    # Авторизованные пользователи (Telegram IDs)
    # Оставьте пустым для доступа всем пользователям
    # или добавьте ID пользователей, которым разрешено управлять сервоприводом
    # например: AUTHORIZED_USERS = [123456789, 987654321]
    AUTHORIZED_USERS = []

2. Теперь создадим основной файл программы (main.py):

.. code-block:: python

    import time
    import machine
    import uasyncio as asyncio
    from machine import Pin, PWM
    import gc
    
    # Импортируем библиотеку для работы с Telegram
    from telegram import TelegramBot
    
    # Импортируем настройки из config.py
    from config import (WIFI_SSID, WIFI_PASSWORD, BOT_TOKEN, 
                       SERVO_PIN, SERVO_MIN_PULSE, SERVO_MAX_PULSE, SERVO_FREQ,
                       MIN_ANGLE, MAX_ANGLE, AUTHORIZED_USERS)
    
    # Настройка пина для встроенного светодиода
    led = Pin("LED", Pin.OUT)
    
    # Инициализация сервопривода
    servo = PWM(Pin(SERVO_PIN))
    servo.freq(SERVO_FREQ)  # Устанавливаем частоту 50 Гц
    
    # Последний установленный угол
    current_angle = 90
    
    # Функция для мигания светодиодом
    def blink_led(times=1, delay=0.2):
        for _ in range(times):
            led.on()
            time.sleep(delay)
            led.off()
            time.sleep(delay)
    
    # Функция для преобразования угла в значение ШИМ
    def angle_to_duty(angle):
        # Ограничиваем угол в допустимых пределах
        angle = max(MIN_ANGLE, min(MAX_ANGLE, angle))
        
        # Преобразуем угол в длительность импульса
        # Линейная интерполяция между минимальным и максимальным значениями
        pulse_width = SERVO_MIN_PULSE + (SERVO_MAX_PULSE - SERVO_MIN_PULSE) * angle / 180
        
        # Преобразуем длительность импульса в значение duty (0-65535)
        duty = int(pulse_width * 65535 / (1000000 / SERVO_FREQ))
        
        return duty
    
    # Функция для установки угла сервопривода
    def set_servo_angle(angle):
        global current_angle
        
        try:
            # Преобразуем строку в целое число, если необходимо
            if isinstance(angle, str):
                angle = int(angle)
            
            # Ограничиваем угол допустимыми значениями
            angle = max(MIN_ANGLE, min(MAX_ANGLE, angle))
            
            # Устанавливаем ШИМ сигнал для сервопривода
            duty = angle_to_duty(angle)
            servo.duty_u16(duty)
            
            # Запоминаем текущий угол
            current_angle = angle
            
            # Мигаем светодиодом для индикации изменения
            blink_led(1, 0.1)
            
            return True, angle
        except Exception as e:
            print(f"Ошибка при установке угла сервопривода: {e}")
            return False, str(e)
    
    # Функция для проверки авторизации пользователя
    def is_authorized(user_id):
        # Если список авторизованных пользователей пуст, разрешаем всем
        if not AUTHORIZED_USERS:
            return True
        
        # Иначе проверяем, есть ли пользователь в списке
        return user_id in AUTHORIZED_USERS
    
    # Обработчик сообщений для бота
    def message_handler(bot, msg_type, chat_name, sender_name, chat_id, text, entry):
        print(f"Получено сообщение от {sender_name} ({chat_id}): {text}")
        
        # Получаем ID пользователя
        try:
            user_id = entry['message']['from']['id']
        except:
            user_id = None
        
        # Проверяем авторизацию
        if not is_authorized(user_id):
            bot.send(chat_id, "❌ У вас нет доступа к управлению сервоприводом.")
            return
        
        # Обработка команды /start
        if text == "/start":
            welcome_message = f"Привет, {sender_name}! 👋\n"
            welcome_message += "Я бот для управления сервоприводом на Raspberry Pi Pico W.\n"
            welcome_message += "Отправь команду /servo XX, где XX - угол поворота от 0 до 180 градусов.\n"
            welcome_message += "Например: /servo 90"
            bot.send(chat_id, welcome_message)
        
        # Обработка команды /help
        elif text == "/help":
            help_message = "Доступные команды:\n"
            help_message += "/start - Начать работу с ботом\n"
            help_message += "/help - Показать эту справку\n"
            help_message += "/servo XX - Установить угол сервопривода (0-180)\n"
            help_message += "/angle - Показать текущий угол\n"
            help_message += "/status - Показать статус устройства"
            bot.send(chat_id, help_message)
        
        # Обработка команды /status
        elif text == "/status":
            uptime_sec = time.time()
            uptime_min = uptime_sec // 60
            uptime_hours = uptime_min // 60
            
            status_message = "📊 Статус устройства:\n"
            status_message += f"🕒 Время работы: {int(uptime_hours)}ч {int(uptime_min % 60)}м {int(uptime_sec % 60)}с\n"
            status_message += f"💾 Свободная память: {gc.mem_free()} байт\n"
            status_message += f"🌡️ Температура CPU: {machine.internal_temp() - 20} °C\n"  # Коррекция для более точных показаний
            status_message += f"🔄 Текущий угол сервопривода: {current_angle}°"
            
            bot.send(chat_id, status_message)
        
        # Обработка команды /angle
        elif text == "/angle":
            bot.send(chat_id, f"🔄 Текущий угол сервопривода: {current_angle}°")
        
        # Обработка команды /servo XX
        elif text.startswith("/servo "):
            try:
                # Извлекаем угол из команды
                angle_str = text.split("/servo ")[1].strip()
                angle = int(angle_str)
                
                # Проверяем диапазон
                if angle < MIN_ANGLE or angle > MAX_ANGLE:
                    bot.send(chat_id, f"❌ Угол должен быть от {MIN_ANGLE} до {MAX_ANGLE} градусов.")
                    return
                
                # Устанавливаем угол
                success, result = set_servo_angle(angle)
                
                if success:
                    bot.send(chat_id, f"✅ Угол сервопривода установлен: {result}°")
                else:
                    bot.send(chat_id, f"❌ Ошибка при установке угла: {result}")
            
            except ValueError:
                bot.send(chat_id, "❌ Некорректный формат команды. Используйте: /servo XX, где XX - число от 0 до 180.")
            except Exception as e:
                bot.send(chat_id, f"❌ Произошла ошибка: {str(e)}")
        
        # Для неизвестных команд
        else:
            bot.send(chat_id, "❓ Неизвестная команда. Отправьте /help для списка доступных команд.")
    
    # Асинхронная функция для запуска бота
    async def run_bot():
        print("Запуск Telegram-бота...")
        bot = TelegramBot(BOT_TOKEN, message_handler)
        
        # Запускаем основной цикл бота
        try:
            print("Бот запущен! Ожидание команд...")
            await bot.run()
        except Exception as e:
            print(f"Ошибка в работе бота: {e}")
            # Мигаем светодиодом при ошибке
            for _ in range(5):
                blink_led(3, 0.1)
                time.sleep(0.5)
    
    # Главная функция программы
    async def main():
        # Импортируем gc для отслеживания памяти
        import gc
        gc.collect()
        
        print("Инициализация...")
        
        # Индикация запуска с помощью светодиода
        blink_led(3, 0.2)
        
        # Устанавливаем сервопривод в исходное положение (90 градусов)
        set_servo_angle(90)
        print("Сервопривод установлен в исходное положение (90°)")
        
        # Подключаемся к Wi-Fi
        print(f"Подключение к Wi-Fi: {WIFI_SSID}...")
        
        bot = TelegramBot(BOT_TOKEN, message_handler)
        bot.connect_wifi(WIFI_SSID, WIFI_PASSWORD)
        
        # Мигаем светодиодом после успешного подключения
        blink_led(5, 0.1)
        
        print("Wi-Fi подключен!")
        
        # Запускаем бота в отдельной задаче
        bot_task = asyncio.create_task(run_bot())
        
        # Запускаем периодическую очистку памяти и проверку работоспособности
        while True:
            gc.collect()
            led.on()  # Светодиод горит, показывая, что программа работает
            await asyncio.sleep(2)
            led.off()
            await asyncio.sleep(2)
    
    # Запускаем программу с помощью асинхронного цикла событий
    if __name__ == "__main__":
        try:
            asyncio.run(main())
        except Exception as e:
            print(f"Критическая ошибка: {e}")
            machine.reset()  # Перезагрузка при критической ошибке

Загрузка и запуск проекта
-----------------------------------------

1. Убедитесь, что на вашем Raspberry Pi Pico W установлен MicroPython с поддержкой Wi-Fi.

2. Скопируйте файл telegram.py (библиотека для работы с Telegram API) на ваш Pico W.

3. Создайте и загрузите на Pico W файлы:
   - config.py (с вашими настройками Wi-Fi, токеном бота и параметрами сервопривода)
   - main.py (с кодом бота и управлением сервоприводом)

4. Отредактируйте файл config.py, указав:
   - Имя и пароль вашей Wi-Fi сети
   - Токен вашего Telegram-бота, полученный от BotFather
   - При необходимости настройте параметры сервопривода (SERVO_MIN_PULSE, SERVO_MAX_PULSE)
   - Если нужно ограничить доступ, добавьте ID пользователей в список AUTHORIZED_USERS

5. Подключите сервопривод к Pico W согласно схеме:
   - VCC (красный) -> VBUS (5В)
   - GND (коричневый/черный) -> GND
   - Signal (желтый/оранжевый) -> GP15

6. Запустите программу, нажав кнопку Run в Thonny или перезагрузив Pico W.

7. Найдите своего бота в Telegram по имени, которое вы указали при создании, и отправьте ему команду `/start`.

8. После приветственного сообщения вы можете управлять сервоприводом командой `/servo XX`, где XX - угол от 0 до 180 градусов.

Как это работает
-----------------------------------------

1. **Инициализация сервопривода**:
   - Создаем объект PWM на указанном пине (GP15 по умолчанию)
   - Устанавливаем частоту 50 Гц (стандартная для сервоприводов)
   - По умолчанию устанавливаем сервопривод в среднее положение (90 градусов)

2. **Управление сервоприводом**:
   - Функция `angle_to_duty` преобразует угол (0-180) в значение ШИМ
   - Для преобразования используем линейную интерполяцию между минимальным и максимальным значениями импульса
   - Функция `set_servo_angle` устанавливает сервопривод в указанное положение, ограничивая угол в допустимых пределах

3. **Обработка команд Telegram**:
   - Бот принимает команду в формате `/servo XX`
   - Извлекает значение угла из команды, проверяет его на корректность
   - Вызывает функцию `set_servo_angle` для установки сервопривода
   - Отправляет сообщение с результатом операции

4. **Дополнительные функции**:
   - Команда `/angle` показывает текущий угол сервопривода
   - Команда `/status` отображает информацию о состоянии устройства
   - Система авторизации позволяет ограничить доступ к управлению сервоприводом

5. **Индикация работы**:
   - Встроенный светодиод мигает при обработке команд
   - Периодическое мигание светодиода показывает, что программа работает

Калибровка сервопривода
-----------------------------------------

Разные модели сервоприводов могут иметь различные характеристики импульсов для управления. Если ваш сервопривод не поворачивается на точный угол, необходимо выполнить калибровку:

1. Измените значения SERVO_MIN_PULSE и SERVO_MAX_PULSE в файле config.py:
   - Если сервопривод не достигает 0 градусов, уменьшите SERVO_MIN_PULSE
   - Если сервопривод не достигает 180 градусов, увеличьте SERVO_MAX_PULSE
   - Типичные значения: 500-2500 мкс (в некоторых случаях 544-2400 мкс)

2. Для точной калибровки выполните следующие шаги:
   - Отправьте команду `/servo 0` и проверьте, соответствует ли положение 0 градусам
   - Отправьте команду `/servo 180` и проверьте, соответствует ли положение 180 градусам
   - Корректируйте значения SERVO_MIN_PULSE и SERVO_MAX_PULSE итеративно

3. Если сервопривод дрожит в крайних положениях, это может означать, что:
   - Значения импульсов выходят за пределы допустимых для данной модели
   - Сервопривод не может достичь механических ограничений

Возможные проблемы и их решения
-----------------------------------------

1. **Сервопривод не двигается или двигается рывками**:
   - Проверьте правильность подключения проводов (VCC, GND, Signal)
   - Убедитесь, что питание достаточно для вашего сервопривода (особенно для больших сервоприводов)
   - Если используете внешнее питание, убедитесь, что GND внешнего источника соединен с GND Pico W

2. **Сервопривод не достигает крайних положений**:
   - Откалибруйте значения SERVO_MIN_PULSE и SERVO_MAX_PULSE (см. раздел "Калибровка сервопривода")
   - Проверьте, не касается ли рычаг сервопривода механических препятствий

3. **Бот не отвечает на команды**:
   - Проверьте подключение к Wi-Fi
   - Убедитесь, что токен бота указан правильно
   - Включите режим отладки в библиотеке TelegramBot для получения дополнительной информации

4. **Высокое энергопотребление**:
   - Сервоприводы могут потреблять значительный ток при движении
   - Для экономии энергии можно отключать ШИМ сигнал после установки положения:

     ```python
     # Отключение ШИМ сигнала:
     servo.duty_u16(0)
     ```
     
   - Однако это приведет к тому, что сервопривод перестанет удерживать позицию активно

5. **Ошибки при запросе угла через декорации текста**:
   - Если получаете ошибки при отправке/получении сообщений с эмодзи, проверьте версию MicroPython
   - В некоторых случаях может потребоваться обновление прошивки

Расширение проекта
-----------------------------------------

1. **Добавление нескольких сервоприводов**:
   - Добавьте дополнительные PWM объекты для других пинов
   - Реализуйте команды для управления каждым сервоприводом отдельно (`/servo1`, `/servo2` и т.д.)
   - Создайте команды для выполнения сложных последовательностей движений

2. **Интеграция с другими компонентами**:
   - Добавьте датчики (например, ультразвуковой дальномер) для автоматической регулировки положения
   - Создайте систему с обратной связью, где положение сервопривода зависит от внешних факторов
   - Используйте сервопривод для управления камерой, создавая простую систему видеонаблюдения

3. **Улучшение интерфейса бота**:
   - Добавьте Inline-клавиатуру с предустановленными углами (0°, 45°, 90°, 135°, 180°)
   - Реализуйте "слайдер" для плавного изменения угла
   - Добавьте поддержку голосовых команд для управления сервоприводом

4. **Безопасность и логирование**:
   - Ведите журнал всех команд и изменений положения
   - Добавьте временные ограничения на частоту изменения положения
   - Реализуйте автоматическое возвращение в безопасное положение при потере связи

5. **Энергосбережение**:
   - Добавьте режим сна для экономии энергии
   - Реализуйте автоматическое отключение удержания позиции после периода неактивности
   - Используйте аккумулятор и контроль уровня заряда для мобильного применения

Заключение
-----------------------------------------

В этом уроке мы создали систему дистанционного управления сервоприводом через Telegram-бот с использованием Raspberry Pi Pico W. Мы научились работать с ШИМ для точного управления углом поворота сервопривода и реализовали простой и понятный интерфейс управления через команды в мессенджере.

Такая система представляет собой базовый пример управления физическими устройствами через интернет и может быть расширена для создания более сложных робототехнических проектов, систем умного дома или дистанционно управляемых механизмов.

Благодаря низкому энергопотреблению Raspberry Pi Pico W и удобству интерфейса Telegram, система может работать автономно в течение длительного времени и управляться с любого устройства, имеющего доступ к интернету.

.. note::
    
    При работе с сервоприводами важно учитывать их момент силы и ток потребления. Для больших сервоприводов или при высоких нагрузках всегда используйте внешний источник питания, чтобы избежать перегрузки и повреждения Raspberry Pi Pico W.
