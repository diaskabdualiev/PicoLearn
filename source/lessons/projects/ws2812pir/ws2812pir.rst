PIR-датчик: уведомление о движении с помощью WS2812
=====================================================================

Введение
-----------------------------------------

В этом уроке мы создадим простую «охранную» систему с помощью PIR-датчика движения и адресной светодиодной ленты WS2812. Наша система будет обнаруживать движение в помещении и сигнализировать о нём яркими световыми эффектами на светодиодной ленте. Такая система может использоваться для оповещения о посетителях, в качестве элемента умного дома или как часть более сложной охранной системы.

Необходимые компоненты
-----------------------------------------

- Raspberry Pi Pico W
- PIR-датчик движения (HC-SR501 или аналогичный)
- Адресная светодиодная лента WS2812B (кольцо из 12 светодиодов)
- Провода для подключения
- Резистор 470 Ом (для защиты первого светодиода)
- Макетная плата (опционально)
- Источник питания 5В (если используется только кольцо из 12 светодиодов, можно питать от Pico W)

Схема подключения
-----------------------------------------

1. **Подключение PIR-датчика движения к Raspberry Pi Pico W**:
   - VCC датчика к VBUS (5В) или 3V3 Pico W (зависит от модели датчика)
   - GND датчика к GND Pico W
   - OUT (сигнальный вывод) датчика к GP16 (PIN 21) Pico W

2. **Подключение адресной ленты WS2812B к Raspberry Pi Pico W**:
   - VCC ленты к VBUS (5В) Pico W (PIN 40)
   - GND ленты к GND Pico W (PIN 38)
   - DIN (вход данных) ленты к GP28 (PIN 34) Pico W через резистор 470 Ом

.. note::
    
    PIR-датчики обычно имеют время инициализации около 1 минуты после подачи питания. В течение этого времени датчик может выдавать ложные срабатывания, пока не стабилизируется. Учитывайте это при тестировании.

Структура проекта
-----------------------------------------

Наш проект будет состоять из следующих файлов:
- config.py - конфигурационный файл с настройками
- neopixel.py - библиотека для работы с адресной лентой WS2812B
- main.py - основной файл программы

Код проекта
-----------------------------------------

1. Сначала создадим файл конфигурации (config.py):

.. code-block:: python

    # Конфигурационный файл для проекта PIR-датчика с WS2812
    
    # Настройки PIR-датчика
    PIR_PIN = 16           # Номер GPIO пина для PIR-датчика
    PIR_COOLDOWN = 5       # Время "остывания" в секундах после срабатывания
    
    # Настройки светодиодной ленты
    LED_COUNT = 12         # Количество светодиодов в кольце
    LED_PIN = 28           # Номер GPIO пина для управления лентой
    LED_BRIGHTNESS = 0.3   # Яркость от 0.0 до 1.0
    
    # Режимы работы
    ALARM_DURATION = 10    # Продолжительность тревоги в секундах
    STANDBY_COLOR = (0, 0, 32)  # Цвет в режиме ожидания (синий)
    ALARM_COLOR = (255, 0, 0)   # Цвет тревоги (красный)

2. Теперь добавим основной файл программы (main.py):

.. code-block:: python

    import time
    import machine
    from machine import Pin
    import neopixel
    import random
    
    # Импортируем настройки из config.py
    from config import (PIR_PIN, PIR_COOLDOWN, LED_COUNT, LED_PIN, 
                       LED_BRIGHTNESS, ALARM_DURATION, STANDBY_COLOR, ALARM_COLOR)
    
    # Настройка пина для встроенного светодиода
    led = Pin("LED", Pin.OUT)
    
    # Настройка PIR-датчика
    pir = Pin(PIR_PIN, Pin.IN, Pin.PULL_DOWN)
    
    # Инициализация адресной ленты WS2812B
    pixels = neopixel.NeoPixel(Pin(LED_PIN), LED_COUNT)
    
    # Установка начальной яркости
    brightness = LED_BRIGHTNESS
    
    # Переменные для отслеживания состояния
    alarm_active = False
    last_trigger_time = 0
    
    # Функция для мигания встроенным светодиодом
    def blink_led(times=1, delay=0.2):
        for _ in range(times):
            led.on()
            time.sleep(delay)
            led.off()
            time.sleep(delay)
    
    # Функция для настройки яркости цвета
    def adjust_brightness(color):
        r, g, b = color
        return (int(r * brightness), int(g * brightness), int(b * brightness))
    
    # Функция для установки всех пикселей в один цвет
    def set_all_pixels(color):
        adjusted_color = adjust_brightness(color)
        for i in range(LED_COUNT):
            pixels[i] = adjusted_color
        pixels.write()
    
    # Функция для эффекта "полицейской мигалки"
    def police_effect(duration=10):
        start_time = time.time()
        while time.time() - start_time < duration:
            # Красный цвет
            for i in range(LED_COUNT):
                if i % 2 == 0:  # Четные пиксели
                    pixels[i] = adjust_brightness((255, 0, 0))
                else:  # Нечетные пиксели
                    pixels[i] = adjust_brightness((0, 0, 0))
            pixels.write()
            time.sleep(0.1)
            
            # Синий цвет
            for i in range(LED_COUNT):
                if i % 2 == 0:  # Четные пиксели
                    pixels[i] = adjust_brightness((0, 0, 0))
                else:  # Нечетные пиксели
                    pixels[i] = adjust_brightness((0, 0, 255))
            pixels.write()
            time.sleep(0.1)
    
    # Функция для эффекта "тревожной пульсации"
    def pulse_effect(color, duration=10, cycles=5):
        start_time = time.time()
        while time.time() - start_time < duration:
            # Нарастание яркости
            for i in range(20):
                factor = i / 20
                r = int(color[0] * factor)
                g = int(color[1] * factor)
                b = int(color[2] * factor)
                set_all_pixels((r, g, b))
                time.sleep(0.02)
            
            # Затухание яркости
            for i in range(20, 0, -1):
                factor = i / 20
                r = int(color[0] * factor)
                g = int(color[1] * factor)
                b = int(color[2] * factor)
                set_all_pixels((r, g, b))
                time.sleep(0.02)
    
    # Функция для эффекта "бегущих огней"
    def chase_effect(color, duration=10, speed=0.05):
        start_time = time.time()
        position = 0
        
        while time.time() - start_time < duration:
            # Очищаем все пиксели
            set_all_pixels((0, 0, 0))
            
            # Зажигаем 3 последовательных пикселя
            for i in range(3):
                pixel_pos = (position + i) % LED_COUNT
                pixels[pixel_pos] = adjust_brightness(color)
            
            pixels.write()
            position = (position + 1) % LED_COUNT
            time.sleep(speed)
    
    # Функция для случайного мигания (эффект "взлома")
    def glitch_effect(color, duration=10):
        start_time = time.time()
        
        while time.time() - start_time < duration:
            # Случайное количество активных пикселей
            active_count = random.randint(1, LED_COUNT)
            
            # Очищаем все пиксели
            set_all_pixels((0, 0, 0))
            
            # Зажигаем случайные пиксели
            for _ in range(active_count):
                pixel_pos = random.randint(0, LED_COUNT - 1)
                pixels[pixel_pos] = adjust_brightness(color)
            
            pixels.write()
            time.sleep(random.uniform(0.05, 0.2))
    
    # Функция для активации тревоги с выбором случайного эффекта
    def activate_alarm():
        global alarm_active
        
        print("Обнаружено движение! Активация тревоги!")
        
        # Включаем встроенный светодиод
        led.on()
        
        # Устанавливаем флаг активной тревоги
        alarm_active = True
        
        # Выбираем случайный эффект тревоги
        effect = random.randint(1, 4)
        
        if effect == 1:
            print("Эффект: Полицейская мигалка")
            police_effect(ALARM_DURATION)
        elif effect == 2:
            print("Эффект: Тревожная пульсация")
            pulse_effect(ALARM_COLOR, ALARM_DURATION)
        elif effect == 3:
            print("Эффект: Бегущие огни")
            chase_effect(ALARM_COLOR, ALARM_DURATION)
        else:
            print("Эффект: Взлом")
            glitch_effect(ALARM_COLOR, ALARM_DURATION)
        
        # Выключаем встроенный светодиод
        led.off()
        
        # Сбрасываем флаг тревоги
        alarm_active = False
        
        # Возвращаемся в режим ожидания
        set_all_pixels(STANDBY_COLOR)
    
    # Функция для обработки прерывания от PIR-датчика
    def handle_pir_interrupt(pin):
        global last_trigger_time, alarm_active
        
        current_time = time.time()
        
        # Проверяем, прошло ли достаточно времени с последнего срабатывания
        if current_time - last_trigger_time > PIR_COOLDOWN:
            # Обновляем время последнего срабатывания
            last_trigger_time = current_time
            
            # Если тревога не активна, запускаем её
            if not alarm_active:
                activate_alarm()
    
    # Главная функция
    def main():
        print("Инициализация системы обнаружения движения...")
        
        # Устанавливаем цвет ожидания
        set_all_pixels(STANDBY_COLOR)
        
        # Мигаем встроенным светодиодом для индикации запуска
        blink_led(3, 0.2)
        
        # Настраиваем прерывание от PIR-датчика
        pir.irq(trigger=Pin.IRQ_RISING, handler=handle_pir_interrupt)
        
        print("Система готова к обнаружению движения!")
        print("Режим ожидания активен...")
        
        # Бесконечный цикл для поддержания работы программы
        try:
            while True:
                # Просто ждем прерываний от датчика
                time.sleep(1)
        except KeyboardInterrupt:
            # При нажатии Ctrl+C выключаем все светодиоды
            set_all_pixels((0, 0, 0))
            print("Программа остановлена пользователем")
    
    # Запускаем программу
    if __name__ == "__main__":
        main()

Загрузка и запуск проекта
-----------------------------------------

1. Убедитесь, что у вас есть библиотека neopixel.py для работы с адресными светодиодами WS2812B. Если её нет, скачайте из официального репозитория micropython-lib.

2. Подключите Raspberry Pi Pico W к компьютеру через USB.

3. Создайте и загрузите на Pico W следующие файлы:
   - config.py (с настройками проекта)
   - main.py (основной код программы)
   - neopixel.py (библиотека для управления светодиодами)

4. Соберите схему согласно разделу "Схема подключения".

5. Запустите программу, нажав кнопку Run в Thonny или перезагрузив Pico W.

6. После запуска светодиодное кольцо должно загореться синим цветом (режим ожидания).

7. При обнаружении движения перед PIR-датчиком светодиодная лента активирует один из эффектов тревоги на заданное время, а затем вернется в режим ожидания.

Как это работает
-----------------------------------------

1. **Инициализация**:
   - Программа настраивает PIR-датчик движения на указанном пине.
   - Инициализируется светодиодная лента WS2812B.
   - Устанавливается режим ожидания (синее свечение).

2. **Обнаружение движения**:
   - PIR-датчик генерирует прерывание при обнаружении движения.
   - Обработчик прерывания проверяет, прошло ли достаточно времени с последнего срабатывания (чтобы избежать множественных срабатываний).
   - Если условие выполняется и тревога не активна, запускается функция активации тревоги.

3. **Активация тревоги**:
   - Случайным образом выбирается один из четырех эффектов тревоги.
   - Включается встроенный светодиод.
   - Выбранный эффект запускается на заданное в конфигурации время.
   - После завершения эффекта система возвращается в режим ожидания.

4. **Эффекты тревоги**:
   - **Полицейская мигалка**: чередование красных и синих вспышек, напоминающих полицейскую сирену.
   - **Тревожная пульсация**: плавное нарастание и затухание красного цвета на всех светодиодах.
   - **Бегущие огни**: группа светодиодов красного цвета, движущаяся по кругу.
   - **Эффект "взлома"**: случайное мигание светодиодов разной интенсивности, создающее хаотичный эффект.

Возможные проблемы и их решения
-----------------------------------------

1. **PIR-датчик не срабатывает**:
   - Убедитесь, что датчик правильно подключен (VCC, GND, OUT).
   - Проверьте, что питание датчика соответствует его требованиям (3.3В или 5В).
   - Многие PIR-датчики имеют регуляторы чувствительности и времени задержки - настройте их соответствующим образом.
   - Помните о времени инициализации PIR-датчика (около 1 минуты).

2. **Светодиоды не включаются или работают некорректно**:
   - Проверьте правильность подключения ленты (VCC, GND, DIN).
   - Убедитесь, что вы используете правильный GPIO пин в конфигурации.
   - Проверьте напряжение питания - для WS2812B требуется 5В.
   - Уменьшите яркость в config.py - возможно, ваш источник питания не обеспечивает достаточной мощности.

3. **Частые ложные срабатывания**:
   - Увеличьте значение PIR_COOLDOWN в config.py для увеличения времени между срабатываниями.
   - Настройте потенциометры на PIR-датчике для снижения чувствительности.
   - Установите датчик в месте с меньшим количеством тепловых помех (не напротив окон, радиаторов отопления и т.д.).

4. **Система зависает или перезагружается**:
   - Уменьшите сложность эффектов тревоги или их продолжительность.
   - Проверьте качество подключения и питания.
   - Добавьте больше вызовов machine.mem_free() для мониторинга доступной памяти.

Расширение проекта
-----------------------------------------

1. **Добавление звукового сигнала**:
   - Подключите пьезодинамик к дополнительному пину Pico W.
   - Добавьте функции для генерации звуковых сигналов при активации тревоги.

2. **Беспроводные уведомления**:
   - Используйте Wi-Fi модуль Pico W для отправки уведомлений на смартфон или другие устройства при обнаружении движения.
   - Интегрируйте с Telegram-ботом, электронной почтой или системой умного дома.

3. **Расширенные режимы работы**:
   - Добавьте кнопку или веб-интерфейс для переключения между различными режимами (полная охрана, ночной режим, дневной режим и т.д.).
   - Реализуйте автоматическое включение/выключение режима охраны по расписанию.

4. **Интеграция с дополнительными датчиками**:
   - Добавьте датчик освещенности для автоматической регулировки яркости светодиодов.
   - Подключите датчик шума для активации тревоги не только при движении, но и при громких звуках.
   - Используйте датчик температуры для предотвращения ложных срабатываний при резких изменениях температуры.

5. **Запись журнала событий**:
   - Сохраняйте информацию о срабатываниях датчика с временными метками во встроенную память или на внешнюю SD-карту.
   - Создайте веб-интерфейс для просмотра журнала и статистики срабатываний.

Заключение
-----------------------------------------

В этом уроке мы создали простую, но эффективную систему обнаружения движения с использованием PIR-датчика и адресной светодиодной ленты WS2812B. Наша система может служить как простой охранной индикацией, так и основой для более сложных проектов умного дома.

Проект демонстрирует, как с помощью доступных компонентов и несложного кода можно создать функциональное устройство с привлекательной визуальной индикацией. Различные эффекты тревоги делают систему не только полезной, но и интересной с точки зрения визуального восприятия.

Благодаря модульной структуре кода и возможностям расширения, вы можете адаптировать эту базовую систему под свои конкретные нужды и добавлять новые функции по мере необходимости.

.. note::
    
    Для использования в реальных условиях охраны рекомендуется добавить резервное питание (например, аккумулятор), а также реализовать отправку уведомлений на мобильные устройства или интеграцию с существующими системами охраны.
