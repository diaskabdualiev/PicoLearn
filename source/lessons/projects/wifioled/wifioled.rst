Отображение информации о Wi-Fi на OLED-дисплее SSD1306
=====================================================================

Введение
-----------------------------------------

В этом уроке мы научимся отображать сетевую информацию на OLED-дисплее SSD1306 с помощью Raspberry Pi Pico W. Наше устройство будет автоматически подключаться к Wi-Fi сети и отображать свой IP-адрес, название точки доступа (SSID) и уровень сигнала на дисплее. Это очень полезно для IoT проектов, когда вам нужно быстро узнать сетевые параметры вашего устройства без подключения к компьютеру.

Необходимые компоненты
-----------------------------------------

- Raspberry Pi Pico W
- OLED-дисплей SSD1306 с интерфейсом I2C (обычно 128x64 или 128x32 пикселей)
- Соединительные провода
- Макетная плата (опционально)

Схема подключения
-----------------------------------------

OLED-дисплей SSD1306 подключается к Raspberry Pi Pico W через интерфейс I2C:

- VCC дисплея к 3.3V (PIN 36) Pico W
- GND дисплея к GND (PIN 38) Pico W
- SCL дисплея к GP1 (PIN 2) Pico W - это I2C0 SCL
- SDA дисплея к GP0 (PIN 1) Pico W - это I2C0 SDA

.. note::
    
    Убедитесь, что ваш OLED-дисплей рассчитан на напряжение 3.3В. Если ваш дисплей рассчитан на 5В, но работает и с 3.3В (многие современные дисплеи совместимы), то подключение безопасно. В противном случае может потребоваться преобразователь уровня.

Структура проекта
-----------------------------------------

Наш проект будет состоять из следующих файлов:
- config.py - конфигурационный файл (логин/пароль Wi-Fi)
- main.py - основной файл программы
- ssd1306.py - библиотека для работы с OLED-дисплеем (уже включена в micropython-lib)

Код проекта
-----------------------------------------

1. Сначала создадим файл конфигурации (config.py):

.. code-block:: python

    # Конфигурационный файл для проекта OLED Wi-Fi Info
    
    # Настройки Wi-Fi
    WIFI_SSID = "Название_вашей_сети"
    WIFI_PASSWORD = "Пароль_вашей_сети"

2. Создадим основной файл программы (main.py):

.. code-block:: python

    import network
    import time
    import machine
    from machine import Pin, I2C
    import ssd1306
    import gc
    
    # Импортируем настройки Wi-Fi из config.py
    from config import WIFI_SSID, WIFI_PASSWORD
    
    # Настройка пина для встроенного светодиода
    led = Pin("LED", Pin.OUT)
    
    # Настройка I2C для OLED-дисплея
    i2c = I2C(0, scl=Pin(1), sda=Pin(0), freq=400000)
    
    # Определение размеров дисплея
    # Обычно 128x64 или 128x32, в зависимости от вашей модели
    DISPLAY_WIDTH = 128
    DISPLAY_HEIGHT = 64
    
    try:
        # Инициализация дисплея
        display = ssd1306.SSD1306_I2C(DISPLAY_WIDTH, DISPLAY_HEIGHT, i2c)
        display_available = True
    except Exception as e:
        print("Ошибка инициализации дисплея:", e)
        display_available = False
    
    # Эта функция будет отображать сообщение на дисплее
    def show_message(title, lines, clear=True):
        if not display_available:
            return
            
        if clear:
            display.fill(0)  # Очищаем дисплей
            
        # Отображаем заголовок
        display.text(title, 0, 0, 1)
        display.hline(0, 10, DISPLAY_WIDTH, 1)  # Горизонтальная линия под заголовком
        
        # Отображаем строки текста
        y = 12
        for line in lines:
            display.text(line, 0, y, 1)
            y += 10
            
        # Обновляем дисплей
        display.show()
    
    # Функция для мигания встроенным светодиодом
    def blink_led(times=1, delay=0.2):
        for _ in range(times):
            led.on()
            time.sleep(delay)
            led.off()
            time.sleep(delay)
    
    # Функция для отображения информации о загрузке
    def show_loading():
        show_message("Pico W", ["Starting...", "Connecting to WiFi"])
    
    # Функция для получения уровня сигнала Wi-Fi в виде графического представления
    def get_signal_strength_bars(rssi):
        # RSSI обычно от -30 (отлично) до -90 (очень слабо)
        if rssi >= -50:
            return "[||||]"  # Отличный сигнал
        elif rssi >= -60:
            return "[||| ]"  # Хороший сигнал
        elif rssi >= -70:
            return "[||  ]"  # Средний сигнал
        elif rssi >= -80:
            return "[|   ]"  # Слабый сигнал
        else:
            return "[    ]"  # Очень слабый сигнал
    
    # Функция подключения к Wi-Fi
    def connect_to_wifi():
        # Показываем сообщение о загрузке
        show_loading()
        
        # Настраиваем Wi-Fi интерфейс
        wlan = network.WLAN(network.STA_IF)
        wlan.active(True)
        
        # Если уже подключены - отключаемся
        if wlan.isconnected():
            wlan.disconnect()
            time.sleep(1)
        
        print(f"Подключение к Wi-Fi сети {WIFI_SSID}...")
        
        # Показываем процесс подключения на дисплее
        show_message("WiFi Connect", [f"SSID: {WIFI_SSID}", "Connecting..."])
        
        # Пытаемся подключиться к Wi-Fi
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)
        
        # Ждем подключения с таймаутом
        max_wait = 20
        while max_wait > 0:
            if wlan.isconnected():
                break
            
            # Мигаем светодиодом в процессе подключения
            blink_led(1, 0.1)
            
            max_wait -= 1
            print("Ожидание подключения...")
            
            # Обновляем сообщение на дисплее с точками
            dots = "." * ((20 - max_wait) % 4 + 1)
            show_message("WiFi Connect", [f"SSID: {WIFI_SSID}", f"Connecting{dots}"])
            
            time.sleep(1)
        
        # Проверяем результат подключения
        if wlan.isconnected():
            # Получаем информацию о сети
            ip_address = wlan.ifconfig()[0]
            ssid = WIFI_SSID
            
            # Получаем силу сигнала
            rssi = wlan.status('rssi')
            signal_bars = get_signal_strength_bars(rssi)
            
            print(f"Подключено к {ssid}")
            print(f"IP-адрес: {ip_address}")
            print(f"Уровень сигнала: {rssi} dBm {signal_bars}")
            
            # Отображаем информацию на дисплее
            show_message("WiFi Connected", [
                f"SSID: {ssid}",
                f"IP: {ip_address}",
                f"Signal: {rssi} dBm",
                signal_bars
            ])
            
            # Быстро мигаем светодиодом при успешном подключении
            blink_led(3, 0.1)
            
            return True, wlan
        else:
            print("Не удалось подключиться к Wi-Fi")
            
            # Отображаем сообщение об ошибке на дисплее
            show_message("WiFi Error", [
                "Failed to connect",
                f"to {WIFI_SSID}",
                "Check credentials",
                "or signal strength"
            ])
            
            # Медленно мигаем светодиодом при ошибке
            blink_led(3, 0.5)
            
            return False, wlan
    
    # Функция для мониторинга Wi-Fi соединения
    def monitor_wifi(wlan):
        prev_connected = True
        prev_rssi = 0
        
        while True:
            gc.collect()  # Освобождаем память
            
            if not wlan.isconnected():
                if prev_connected:
                    print("Wi-Fi соединение потеряно! Переподключение...")
                    show_message("WiFi Lost", ["Connection lost", "Reconnecting..."])
                    prev_connected = False
                
                # Пытаемся переподключиться
                blink_led(1, 0.2)
                wlan.connect(WIFI_SSID, WIFI_PASSWORD)
                time.sleep(5)
                continue
            
            if not prev_connected:
                print("Wi-Fi соединение восстановлено!")
                prev_connected = True
            
            # Получаем текущий уровень сигнала
            current_rssi = wlan.status('rssi')
            
            # Если уровень сигнала изменился значительно, обновляем информацию
            if abs(current_rssi - prev_rssi) >= 5:
                ip_address = wlan.ifconfig()[0]
                signal_bars = get_signal_strength_bars(current_rssi)
                
                print(f"Уровень сигнала изменился: {current_rssi} dBm {signal_bars}")
                
                # Обновляем информацию на дисплее
                show_message("WiFi Status", [
                    f"SSID: {WIFI_SSID}",
                    f"IP: {ip_address}",
                    f"Signal: {current_rssi} dBm",
                    signal_bars
                ])
                
                prev_rssi = current_rssi
            
            # Мигаем светодиодом для индикации работы
            led.on()
            time.sleep(0.1)
            led.off()
            
            # Ждем перед следующей проверкой
            time.sleep(10)
    
    # Главная функция
    def main():
        if not display_available:
            print("ОШИБКА: OLED-дисплей не найден или неправильно подключен!")
            # Мигаем светодиодом в режиме ошибки
            while True:
                blink_led(5, 0.1)
                time.sleep(1)
        
        try:
            # Отображаем приветственное сообщение
            show_message("Pico W", ["OLED WiFi Monitor", "Starting..."])
            time.sleep(1)
            
            # Подключаемся к Wi-Fi
            connected, wlan = connect_to_wifi()
            
            if connected:
                # Если подключение успешно, начинаем мониторинг
                monitor_wifi(wlan)
            else:
                # Если не удалось подключиться, повторяем попытки
                while True:
                    time.sleep(10)
                    connected, wlan = connect_to_wifi()
                    if connected:
                        monitor_wifi(wlan)
        
        except Exception as e:
            # В случае ошибки отображаем информацию
            print("Произошла ошибка:", e)
            
            if display_available:
                show_message("Error", [str(e)[:16], "Restarting..."])
            
            # Перезагружаем устройство через 5 секунд
            time.sleep(5)
            machine.reset()
    
    # Запускаем программу
    if __name__ == "__main__":
        main()

Загрузка и запуск проекта
-----------------------------------------

1. Убедитесь, что библиотека ssd1306.py установлена в вашей системе MicroPython. Если нет, вы можете загрузить её из официального репозитория micropython-lib.

2. Подключите Raspberry Pi Pico W к компьютеру через USB.

3. Установите Thonny IDE или другую среду разработки для MicroPython, если у вас её ещё нет.

4. Создайте и загрузите на Pico W следующие файлы:
   - config.py (с вашими настройками Wi-Fi)
   - main.py
   - ssd1306.py (если её нет в прошивке)

5. Отредактируйте файл config.py, указав имя и пароль вашей Wi-Fi сети.

6. Убедитесь, что OLED-дисплей правильно подключен к Pico W согласно схеме.

7. Запустите программу, нажав кнопку Run в Thonny или перезагрузив Pico W.

8. После успешного запуска вы увидите на OLED-дисплее информацию о подключении к Wi-Fi, а затем - IP-адрес, название сети и уровень сигнала.

Как это работает
-----------------------------------------

1. **Инициализация дисплея**: 
   - Программа настраивает I2C интерфейс для связи с OLED-дисплеем.
   - Создаёт экземпляр объекта дисплея с помощью библиотеки ssd1306.

2. **Подключение к Wi-Fi**:
   - Функция connect_to_wifi() активирует Wi-Fi модуль и пытается подключиться к сети.
   - В процессе подключения на дисплее отображается анимация с точками.
   - Встроенный светодиод мигает, показывая активность.

3. **Отображение информации**:
   - После успешного подключения программа получает IP-адрес и силу сигнала.
   - Вся эта информация отображается на OLED-дисплее.
   - Уровень сигнала показывается как в dBm, так и в виде графического индикатора.

4. **Мониторинг соединения**:
   - Функция monitor_wifi() постоянно проверяет состояние Wi-Fi подключения.
   - Если соединение потеряно, программа пытается переподключиться.
   - При значительном изменении уровня сигнала информация на дисплее обновляется.

Возможные проблемы и их решения
-----------------------------------------

1. **Дисплей не инициализируется**:
   - Проверьте правильность подключения проводов (SDA, SCL, VCC, GND).
   - Убедитесь, что ваш дисплей работает с напряжением 3.3В.
   - Попробуйте изменить адрес I2C в строке инициализации, если у вашего дисплея другой адрес.

2. **Не удаётся подключиться к Wi-Fi**:
   - Убедитесь, что вы указали правильный SSID и пароль в файле config.py.
   - Проверьте, что ваша Wi-Fi сеть работает в диапазоне 2.4 ГГц (Pico W не поддерживает 5 ГГц).
   - Перезагрузите Pico W и ваш Wi-Fi роутер.

3. **Дисплей показывает только часть информации**:
   - Проверьте значения DISPLAY_WIDTH и DISPLAY_HEIGHT в коде. Для дисплея 128x32 измените DISPLAY_HEIGHT на 32.
   - Если текст слишком длинный, он может не помещаться на экране. Попробуйте сократить выводимую информацию.

4. **Программа зависает или перезагружается**:
   - Это может быть связано с проблемами питания. Убедитесь, что USB-кабель обеспечивает достаточную мощность.
   - Добавьте больше вызовов gc.collect() для освобождения памяти, если программа работает долго.

Расширение проекта
-----------------------------------------

1. **Добавление дополнительной информации**:
   - Отображение времени работы устройства.
   - Вывод статистики по пакетам или другим сетевым параметрам.

2. **Улучшение интерфейса**:
   - Добавление графика изменения уровня сигнала со временем.
   - Создание меню для переключения между разными экранами информации.

3. **Добавление функциональности**:
   - Пинг до шлюза или других хостов и отображение времени отклика.
   - Сканирование доступных Wi-Fi сетей и их отображение.

4. **Автоматизация**:
   - Добавление кнопки для переключения режимов отображения.
   - Автоматическое переподключение к сети с наилучшим сигналом из списка известных сетей.

Заключение
-----------------------------------------

В этом уроке мы научились отображать информацию о Wi-Fi соединении на OLED-дисплее с помощью Raspberry Pi Pico W. Проект демонстрирует, как можно создать простой и полезный инструмент для мониторинга сетевых параметров IoT устройства. Такой дисплей значительно упрощает отладку и использование беспроводных проектов, позволяя быстро узнать IP-адрес и статус соединения без необходимости подключения к компьютеру.

.. note::
    
    Данный проект является отличной основой для создания более сложных устройств мониторинга сети или умного дома. Вы можете расширить его функциональность, добавив другие сенсоры или возможности управления через веб-интерфейс, используя полученный IP-адрес.
