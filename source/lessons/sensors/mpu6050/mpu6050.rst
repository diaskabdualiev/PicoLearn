============================================================================
Измерение ускорения и гироскопических данных с MPU6050 на Raspberry Pi Pico
============================================================================

Введение
============

В этом уроке мы научимся использовать акселерометр и гироскоп MPU6050 (модуль GY-521) с микроконтроллером Raspberry Pi Pico. MPU6050 — это популярный датчик движения, который объединяет в себе трехосевой акселерометр и трехосевой гироскоп, что позволяет измерять ускорение, угловую скорость и ориентацию. Данный модуль широко применяется в робототехнике, дронах, системах стабилизации и различных проектах, требующих определения положения в пространстве.

Необходимые компоненты
==============================================

* Raspberry Pi Pico
* Модуль MPU6050 (GY-521)
* Макетная плата
* Соединительные провода
* Микро-USB кабель для питания и программирования

Структура проекта
================================

Наш проект будет состоять из следующих файлов:

* **mpu6050.py** - библиотека для работы с датчиком MPU6050 (предоставляется)
* **main.py** - основной файл с кодом для чтения данных с датчика

Схема подключения
================================

Модуль MPU6050 подключается к Raspberry Pi Pico по интерфейсу I2C:

* VCC (питание) -> 3.3V (пин 36 на Pico)
* GND (земля) -> GND (пин 38 на Pico)
* SCL (тактовая линия I2C) -> GP1 (пин 2 на Pico)
* SDA (линия данных I2C) -> GP0 (пин 1 на Pico)
* XDA и XCL на модуле не подключаются
* AD0 на модуле подключается к GND (устанавливает I2C адрес 0x68)

.. note::
   Модуль MPU6050 работает от напряжения 3.3В. Подключение к 5В может привести к повреждению датчика.

Пошаговые инструкции
======================================

Шаг 1: Настройка оборудования
--------------------------------------------------------

1. Установите MicroPython на Raspberry Pi Pico, если это еще не сделано.
2. Соберите схему в соответствии с описанием выше.
3. Подключите Pico к компьютеру через USB-кабель.

Шаг 2: Загрузка библиотеки mpu6050.py
--------------------------------------------------------

Для работы с датчиком MPU6050 мы будем использовать готовую библиотеку, которая предоставляется с этим уроком. Скопируйте файл **mpu6050.py** на Raspberry Pi Pico с помощью Thonny IDE или другого удобного метода.

В библиотеке необходимо изменить инициализацию I2C для работы с Raspberry Pi Pico. Найдите строки:

.. code-block:: python

   # Initializing the I2C method for ESP32
   # Pin assignment:
   # SCL -> GPIO 22
   # SDA -> GPIO 21
   self.i2c = SoftI2C(scl=Pin(22), sda=Pin(21), freq=100000)

И замените их на:

.. code-block:: python

   # Initializing the I2C method for Raspberry Pi Pico
   # Pin assignment:
   # SCL -> GPIO 1
   # SDA -> GPIO 0
   self.i2c = SoftI2C(scl=Pin(1), sda=Pin(0), freq=100000)

Шаг 3: Создание основного файла main.py
--------------------------------------------------------

Создайте файл main.py со следующим содержимым:

.. code-block:: python

   from machine import Pin
   import mpu6050
   import time
   
   # Настройка встроенного светодиода для индикации
   led = Pin("LED", Pin.OUT)
   
   # Инициализация датчика MPU6050
   try:
       mpu = mpu6050.MPU6050()
       print("Датчик MPU6050 успешно инициализирован")
   except Exception as e:
       print(f"Ошибка инициализации MPU6050: {e}")
   
   # Функция для мигания светодиодом при чтении данных
   def blink_led():
       led.on()
       time.sleep_ms(50)
       led.off()

Разберем основные части кода:

1. Импортируем необходимые модули:
   * ``Pin`` для управления GPIO и светодиодом
   * ``mpu6050`` - нашу библиотеку для работы с датчиком
   * ``time`` для создания задержек

2. Настраиваем встроенный светодиод для индикации процесса чтения.

3. Создаем объект датчика MPU6050:
   * Используем конструктор из импортированной библиотеки
   * Обрабатываем возможные ошибки при инициализации

4. Определяем функцию ``blink_led()`` для кратковременного включения светодиода при чтении данных.

Теперь добавим функции для чтения и форматирования данных с датчика:

.. code-block:: python

   # Функция для форматирования значений акселерометра и гироскопа
   def format_sensor_data(accel, gyro, temp):
       # Форматирование данных акселерометра
       accel_str = f"Акселерометр (м/с²): X={accel['x']:.2f}, Y={accel['y']:.2f}, Z={accel['z']:.2f}"
       accel_abs = f"Абсолютное ускорение: {mpu.read_accel_abs():.2f} м/с²"
       
       # Форматирование данных гироскопа
       gyro_str = f"Гироскоп (°/с): X={gyro['x']:.2f}, Y={gyro['y']:.2f}, Z={gyro['z']:.2f}"
       
       # Форматирование данных температуры
       temp_str = f"Температура: {temp:.2f} °C"
       
       return accel_str, accel_abs, gyro_str, temp_str
   
   # Функция для расчета угла наклона в градусах
   def calculate_tilt_angles(angle_rad):
       x_angle = angle_rad['x'] * 57.296  # Перевод из радиан в градусы (180/π ≈ 57.296)
       y_angle = angle_rad['y'] * 57.296
       
       return f"Угол наклона: X={x_angle:.2f}°, Y={y_angle:.2f}°"

Разберем эти функции:

1. ``format_sensor_data(accel, gyro, temp)``:
   * Принимает данные акселерометра, гироскопа и температуры
   * Форматирует их в читаемые строки с указанием единиц измерения
   * Также вычисляет абсолютное ускорение (корень из суммы квадратов по трем осям)
   * Возвращает кортеж из строк для вывода

2. ``calculate_tilt_angles(angle_rad)``:
   * Принимает углы наклона в радианах
   * Преобразует их в градусы
   * Возвращает строку с углами наклона по осям X и Y

Теперь добавим основной цикл программы:

.. code-block:: python

   # Основной цикл программы
   def main():
       print("Мониторинг данных с датчика MPU6050")
       print("Нажмите Ctrl+C для завершения.")
       print("----------------------------------")
       
       # Настройка диапазонов измерений
       mpu.set_accel_range(mpu6050._ACC_RNG_2G)  # ±2g
       mpu.set_gyro_range(mpu6050._GYR_RNG_250DEG)  # ±250°/с
       
       try:
           while True:
               # Мигаем светодиодом для индикации чтения
               blink_led()
               
               try:
                   # Чтение данных с датчика
                   accel_data = mpu.read_accel_data(g=False)  # Ускорение в м/с²
                   gyro_data = mpu.read_gyro_data()  # Угловая скорость в °/с
                   temp = mpu.read_temperature()  # Температура в °C
                   angle_data = mpu.read_angle()  # Углы наклона в радианах
                   
                   # Форматирование и вывод данных
                   accel_str, accel_abs, gyro_str, temp_str = format_sensor_data(accel_data, gyro_data, temp)
                   tilt_str = calculate_tilt_angles(angle_data)
                   
                   print(accel_str)
                   print(accel_abs)
                   print(gyro_str)
                   print(temp_str)
                   print(tilt_str)
                   print("----------------------------------")
                   
               except Exception as e:
                   print(f"Ошибка при чтении данных: {e}")
               
               # Ждем перед следующим чтением
               time.sleep(0.5)
               
       except KeyboardInterrupt:
           print("\nМониторинг данных завершен.")
   
   # Запускаем программу
   if __name__ == "__main__":
       main()

Этот блок кода:

1. Создает основную функцию ``main()``:
   * Выводит информационное сообщение о начале работы
   * Настраивает диапазоны измерений акселерометра (±2g) и гироскопа (±250°/с)
   * Входит в бесконечный цикл чтения данных

2. В цикле:
   * Мигает светодиодом для индикации процесса чтения
   * Считывает данные с акселерометра, гироскопа и датчика температуры
   * Также получает углы наклона
   * Форматирует и выводит полученные данные
   * Обрабатывает возможные ошибки при чтении
   * Ждет 0.5 секунды перед следующим измерением

3. Обрабатывает прерывание Ctrl+C для корректного завершения программы

4. Запускает функцию ``main()`` при непосредственном выполнении файла

Инструкции по загрузке и запуску
===============================================

1. Убедитесь, что библиотека mpu6050.py с исправленной инициализацией I2C загружена на ваш Raspberry Pi Pico.
2. Скопируйте файл main.py на Pico (можно использовать Thonny IDE или любой другой метод).
3. После загрузки файла программа автоматически запустится.
4. Откройте последовательный порт (в Thonny это происходит автоматически) для просмотра вывода данных.
5. Наблюдайте за показаниями датчика, обновляющимися каждые 0.5 секунды.
6. Попробуйте наклонять и поворачивать датчик, чтобы увидеть изменения в значениях.
7. Для завершения программы нажмите Ctrl+C.

Возможные проблемы и их решения
==============================================

Датчик не инициализируется
---------------------------------------------------

Если датчик не инициализируется или выдает ошибку:

* Проверьте правильность подключения проводов.
* Убедитесь, что напряжение питания датчика составляет 3.3В.
* Проверьте, что в библиотеке правильно указаны пины для I2C.
* Датчик MPU6050 имеет два возможных адреса: 0x68 (по умолчанию) и 0x69. Если пин AD0 не подключен к GND, попробуйте изменить адрес в коде:

.. code-block:: python

   mpu = mpu6050.MPU6050(addr=0x69)

Неточные или странные показания
-----------------------------------------

Если показания датчика кажутся неточными или странными:

* Поместите датчик на ровную поверхность и перезагрузите Pico, чтобы обнулить начальные показания.
* Проверьте, не подвергается ли датчик вибрациям от других компонентов.
* Для более точных измерений может потребоваться калибровка смещения:

.. code-block:: python

   # Примерный код для калибровки (добавьте перед основным циклом)
   print("Калибровка датчика. Держите MPU6050 неподвижно...")
   offset_x = 0
   offset_y = 0
   offset_z = 0
   
   for _ in range(100):
       gyro = mpu.read_gyro_data()
       offset_x += gyro['x']
       offset_y += gyro['y']
       offset_z += gyro['z']
       time.sleep_ms(10)
   
   # Усреднение смещений
   offset_x /= 100
   offset_y /= 100
   offset_z /= 100
   
   print(f"Калибровка завершена. Смещения: X={offset_x:.2f}, Y={offset_y:.2f}, Z={offset_z:.2f}")

Ошибки I2C коммуникации
-----------------------------------------

Если возникают прерывистые ошибки связи:

* Уменьшите частоту I2C в библиотеке mpu6050.py:

.. code-block:: python

   self.i2c = SoftI2C(scl=Pin(1), sda=Pin(0), freq=50000)  # Снижаем до 50 кГц

* Используйте более короткие соединительные провода.
* Добавьте подтягивающие резисторы (4.7 кОм) на линии SDA и SCL, если их нет на модуле.

Заключение
=====================

В этом уроке мы научились:

* Подключать датчик MPU6050 к Raspberry Pi Pico
* Настраивать библиотеку для работы с датчиком
* Считывать данные акселерометра и гироскопа
* Вычислять углы наклона и абсолютное ускорение
* Отображать полученные данные в удобном формате

Этот проект можно расширить различными способами:

* Добавить фильтрацию данных для устранения шума (например, комплементарный фильтр или фильтр Калмана)
* Реализовать обнаружение определенных движений (тряска, падение, вращение)
* Интегрировать с другими датчиками для создания системы инерциальной навигации
* Использовать данные для управления роботом или стабилизации камеры
* Добавить визуализацию данных на OLED-дисплее или через веб-интерфейс

Полный код программы
=======================================

.. code-block:: python

   from machine import Pin
   import mpu6050
   import time
   
   # Настройка встроенного светодиода для индикации
   led = Pin("LED", Pin.OUT)
   
   # Инициализация датчика MPU6050
   try:
       mpu = mpu6050.MPU6050()
       print("Датчик MPU6050 успешно инициализирован")
   except Exception as e:
       print(f"Ошибка инициализации MPU6050: {e}")
   
   # Функция для мигания светодиодом при чтении данных
   def blink_led():
       led.on()
       time.sleep_ms(50)
       led.off()
   
   # Функция для форматирования значений акселерометра и гироскопа
   def format_sensor_data(accel, gyro, temp):
       # Форматирование данных акселерометра
       accel_str = f"Акселерометр (м/с²): X={accel['x']:.2f}, Y={accel['y']:.2f}, Z={accel['z']:.2f}"
       accel_abs = f"Абсолютное ускорение: {mpu.read_accel_abs():.2f} м/с²"
       
       # Форматирование данных гироскопа
       gyro_str = f"Гироскоп (°/с): X={gyro['x']:.2f}, Y={gyro['y']:.2f}, Z={gyro['z']:.2f}"
       
       # Форматирование данных температуры
       temp_str = f"Температура: {temp:.2f} °C"
       
       return accel_str, accel_abs, gyro_str, temp_str
   
   # Функция для расчета угла наклона в градусах
   def calculate_tilt_angles(angle_rad):
       x_angle = angle_rad['x'] * 57.296  # Перевод из радиан в градусы (180/π ≈ 57.296)
       y_angle = angle_rad['y'] * 57.296
       
       return f"Угол наклона: X={x_angle:.2f}°, Y={y_angle:.2f}°"
   
   # Основной цикл программы
   def main():
       print("Мониторинг данных с датчика MPU6050")
       print("Нажмите Ctrl+C для завершения.")
       print("----------------------------------")
       
       # Настройка диапазонов измерений
       mpu.set_accel_range(mpu6050._ACC_RNG_2G)  # ±2g
       mpu.set_gyro_range(mpu6050._GYR_RNG_250DEG)  # ±250°/с
       
       try:
           while True:
               # Мигаем светодиодом для индикации чтения
               blink_led()
               
               try:
                   # Чтение данных с датчика
                   accel_data = mpu.read_accel_data(g=False)  # Ускорение в м/с²
                   gyro_data = mpu.read_gyro_data()  # Угловая скорость в °/с
                   temp = mpu.read_temperature()  # Температура в °C
                   angle_data = mpu.read_angle()  # Углы наклона в радианах
                   
                   # Форматирование и вывод данных
                   accel_str, accel_abs, gyro_str, temp_str = format_sensor_data(accel_data, gyro_data, temp)
                   tilt_str = calculate_tilt_angles(angle_data)
                   
                   print(accel_str)
                   print(accel_abs)
                   print(gyro_str)
                   print(temp_str)
                   print(tilt_str)
                   print("----------------------------------")
                   
               except Exception as e:
                   print(f"Ошибка при чтении данных: {e}")
               
               # Ждем перед следующим чтением
               time.sleep(0.5)
               
       except KeyboardInterrupt:
           print("\nМониторинг данных завершен.")
   
   # Запускаем программу
   if __name__ == "__main__":
       main()